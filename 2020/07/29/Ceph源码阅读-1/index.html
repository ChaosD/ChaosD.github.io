<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Ceph源码阅读(1)——librbd对rados接口调用 | Chaos' Blog</title><meta name="description" content="因项目需求，近期对于Ceph做一些改动。目标是将Ceph的RADOS系统修改为持久化的分布式对象缓存，并可对接到任意底层存储设备中。本文主要介绍调研过程中，rados的接口调用方法。"><meta name="keywords" content="Ceph,RBD,RADOS,c++"><meta name="author" content="Chaos Dong"><meta name="copyright" content="Chaos Dong"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/07/29/Ceph%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-1/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Ceph源码阅读(1)——librbd对rados接口调用"><meta property="og:url" content="http://yoursite.com/2020/07/29/Ceph%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-1/"><meta property="og:site_name" content="Chaos' Blog"><meta property="og:description" content="因项目需求，近期对于Ceph做一些改动。目标是将Ceph的RADOS系统修改为持久化的分布式对象缓存，并可对接到任意底层存储设备中。本文主要介绍调研过程中，rados的接口调用方法。"><meta property="og:image" content="http://static.oschina.net/uploads/space/2015/1119/145240_0zUe_2460844.jpg"><meta property="article:published_time" content="2020-07-29T12:53:48.000Z"><meta property="article:modified_time" content="2020-07-29T13:13:12.606Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="next" title="Hello World" href="http://yoursite.com/2020/07/29/hello-world/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">4</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></li><li><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Librados"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 Librados</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-librbd"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 librbd</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-librbd%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">2. librbd接口实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-librbd%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 librbd使用实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-librbd%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 librbd读写流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-librbd%E5%B0%8F%E7%BB%93"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 librbd小结</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(http://static.oschina.net/uploads/space/2015/1119/145240_0zUe_2460844.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Chaos' Blog</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></li><li><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Ceph源码阅读(1)——librbd对rados接口调用</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-29 20:53:48"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-29</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-29 21:13:12"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-29</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/Ceph/">Ceph</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-Librados"><a href="#1-1-Librados" class="headerlink" title="1.1 Librados"></a>1.1 Librados</h3><p>Ceph rados分布式存储提供了多种语言的api接口，封装在librados库中。客户可以在客户端调用librados，完成对远端的rados分布式存储系统的访问。我们可以在源码目录中打开librados中的api文件夹，查看相关接口。</p>
<p>librados就是操作rados对象存储的接口。 其接口分为两种：一个是c 接口，其定义在include/librados.h 中。 一个是 c++接口，定义在include/librados.hpp中，实现都在<a target="_blank" rel="noopener" href="http://librados.cc/">librados.cc</a>中实现。</p>
<p>接口主要分为五类[^1]：</p>
<ul>
<li><strong>ceph集群句柄（rados client类的实例）</strong>的创建和销毁，配置，连接等，<strong>pool</strong>的创建和销毁，<strong>io上下文（ioctx）</strong>的创建和销毁等。<ul>
<li>创建一个集群句柄</li>
<li>根据配置文件，命令行参数，环境变量<strong>配置</strong>集群句柄</li>
<li>连接集群，相当于使rados client能够实时通信</li>
<li><strong>创建pool</strong>，配置不同的 crush分布策略，复制级别，位置策略等等</li>
<li><strong>io上下文</strong>的创建及获取</li>
</ul>
</li>
<li><strong>快照相关接口</strong>，librados支持对于整个pool的快照，接口包括快照的创建和销毁，到对应快照版本的回滚，快照查询等等。</li>
<li><strong>同步IO操作接口</strong>，包括读，写，覆盖写，追加写，对象数据克隆，删，截断，获取和设置指定的扩展属性，批量获取扩展属性，迭代器遍历扩展属性，特殊键值对获取等等</li>
<li><strong>异步IO操作接口</strong>包括异步读，异步写，异步覆盖写，异步追加写，异步删，librados还提供了对象的监视功能，通过rados_watch可以注册回调，当对象发生变化时会回调通知上层。</li>
<li><strong>io操作组原子操作</strong>，即可以把对同一个对象的一系列io操作放到一个组里面，最后保证加入到组里的所有io操作保持原子性，要么全部成功，要么全部失败，而不会给用户呈现出文件系统不一致的问题。</li>
</ul>
<p>下述是客户端使用librados连接集群并读写对象的一个实例[^2]：</p>
<ol>
<li>获得集群的句柄，并连接到集群的某个Monitor中.以获得Cluster Map；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">cluster_name</span><span class="params">(<span class="string">&quot;ceph&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">user_name</span><span class="params">(<span class="string">&quot;client.admin&quot;</span>)</span></span>;</span><br><span class="line">librados::Rados cluster ;</span><br><span class="line">cluster.init2(user_name.c_str(), cluster_name.c_str(),  <span class="number">0</span>);</span><br><span class="line">cluster.conf_read_file(<span class="string">&quot;/etc/ceph/ceph.conf&quot;</span>);</span><br><span class="line">cluster.<span class="built_in">connect</span>();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建IO上下文，并绑定一个已经存在的存储池；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">librados::IoCtx io_ctx ;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">pool_name</span><span class="params">(<span class="string">&quot;data&quot;</span>)</span></span>;</span><br><span class="line">cluster.ioctx_create(pool_name.c_str(), io_ctx);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>同步写入一个对象；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">librados::bufferlist bl;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">objectId</span><span class="params">(<span class="string">&quot;hw&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">objectContent</span><span class="params">(<span class="string">&quot;Hello World!&quot;</span>)</span></span>;</span><br><span class="line">bl.append(objectContent);</span><br><span class="line">io_ctx.<span class="built_in">write</span>(objectId, bl, objectContent.<span class="built_in">size</span>(),  <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>为该对象添加扩展属性；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">librados::bufferlist lang_bl;</span><br><span class="line">lang_bl.append(<span class="string">&quot;en_US&quot;</span>);</span><br><span class="line">io_ctx.setxattr(objectId,  <span class="string">&quot;lang&quot;</span>, lang_bl);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>异步读取对象；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">librados::bufferlist read_buf;</span><br><span class="line"><span class="keyword">int</span> read_len  =  <span class="number">4194304</span>;</span><br><span class="line">librados::AioCompletion  *read_completion  =  librados::Rados::aio_create_completion();</span><br><span class="line">io_ctx.aio_read(objectId, read_completion,  &amp;read_buf, read_len,  <span class="number">0</span> );</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>断开连接</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io_ctx.<span class="built_in">close</span>();</span><br><span class="line">cluster.<span class="built_in">shutdown</span>();</span><br></pre></td></tr></table></figure>

<h3 id="1-2-librbd"><a href="#1-2-librbd" class="headerlink" title="1.2 librbd"></a>1.2 librbd</h3><p>Librbd是Ceph提供块存储的库，它实现了RBD接口，基于Librados实现了对块设备的基本操作。[^3]librbd的基本架构及功能如下图所示。</p>
<p><img src= "/img/loading.gif" data-src="https://zhoubofsy.github.io/images/ceph/librbd_frame.png" alt="librbd的基本架构"></p>
<p>Ceph librbd通过调用librados的接口，完成了块设备的接口封装。下面将讲解librbd中的具体实现情况。</p>
<h2 id="2-librbd接口实现"><a href="#2-librbd接口实现" class="headerlink" title="2. librbd接口实现"></a>2. librbd接口实现</h2><p>首先，librbd中调用的rados类如下：，包括：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>声明</th>
<th>定义</th>
<th align="left">注释</th>
</tr>
</thead>
<tbody><tr>
<td>librados::(v14_2_0::)IoCtx</td>
<td>\include\rados\librados.hpp</td>
<td>src\librados\librados_cxx.cc</td>
<td align="left">rados的上下文实例</td>
</tr>
<tr>
<td>librados::(v14_2_0::)AioCompletion</td>
<td>\include\rados\librados.hpp</td>
<td>src\librados\librados_cxx.cc</td>
<td align="left">rados异步操作的回调实现</td>
</tr>
<tr>
<td>librados::(v14_2_0::)Rados</td>
<td>\include\rados\librados.hpp</td>
<td>src\librados\librados_cxx.cc</td>
<td align="left">rados实例</td>
</tr>
</tbody></table>
<p>其中IoCtx是rados的上下文实例，创建时需要绑定一个<strong>存储池</strong>（pool），封装了大量对存储池的操作函数，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; oid, <span class="keyword">bool</span> exclusive)</span></span>; <span class="comment">//创建object</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; oid, bufferlist&amp; bl, <span class="keyword">size_t</span> len, <span class="keyword">uint64_t</span> off)</span> <span class="comment">//从偏移处修改某个对象</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; oid, bufferlist&amp; bl, <span class="keyword">size_t</span> len)</span></span>;<span class="comment">// 在对象末尾追加</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_read</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; oid, AioCompletion *c,</span></span></span><br><span class="line"><span class="function"><span class="params">    bufferlist *pbl, <span class="keyword">size_t</span> len, <span class="keyword">uint64_t</span> off, <span class="keyword">uint64_t</span> snapid)</span></span>;<span class="comment">// 异步读</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_write</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; oid, AioCompletion *c, <span class="keyword">const</span> bufferlist&amp; bl,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> len, <span class="keyword">uint64_t</span> off)</span></span>;<span class="comment">//异步写</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>从以上源码可知，IoCtx中提供了对rados中对象的创建、删除、读写等同步操作接口以及除了同步操作，其中也提供异步操作的接口。</p>
<p>而AioCompletion这个类十分特别。他提供了回调函数的相关接口，即可以简单的理解成，AioCompletion表示我们需要进行的回调函数。</p>
<h3 id="2-1-librbd使用实例"><a href="#2-1-librbd使用实例" class="headerlink" title="2.1 librbd使用实例"></a>2.1 librbd使用实例</h3><p>Ceph的rbd设备使用方法与对象存储的使用有很大的相关性，原因在于rbd本质上是对于rados的再次封装。相关接口可以直接查看*/include/rbd/librbd.hpp*查看。</p>
<ol>
<li>获得集群的句柄，并连接到集群的某个Monitor中.以获得Cluster Map；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">cluster_name</span><span class="params">(<span class="string">&quot;ceph&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">user_name</span><span class="params">(<span class="string">&quot;client.admin&quot;</span>)</span></span>;</span><br><span class="line">librados::Rados cluster ;</span><br><span class="line">cluster.init2(user_name.c_str(), cluster_name.c_str(),  <span class="number">0</span>);</span><br><span class="line">cluster.conf_read_file(<span class="string">&quot;/etc/ceph/ceph.conf&quot;</span>);</span><br><span class="line">cluster.<span class="built_in">connect</span>();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建IO上下文，并绑定一个已经存在的存储池；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">librados::IoCtx io_ctx;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">pool_name</span><span class="params">(<span class="string">&quot;data&quot;</span>)</span></span>;</span><br><span class="line">cluster.ioctx_create(pool_name.c_str(), io_ctx);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建rbd设备，即我们需要的虚拟块设备,并创建image结构，这里该结构将<em>myimag</em>e与<em>ioctx</em> 联系起来，后面可以通过image结构直接找到<em>ioctx</em>。这里会将ioctx复制两份，分为为<em>data_ioctx</em>和<em>md_ctx</em>。见明知意，一个用来处理rbd的存储数据，一个用来处理rbd的管理数据。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rbd_inst.create(ioctx,&#x27;myimage&#x27;,size);</span><br><span class="line">image = rbd.Image(ioctx,&#x27;myimage&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再次之后，我们就可以通过调用image的相关接口，如aio_write，aio_read对该块设备进行读写操作。</p>
<h3 id="2-2-librbd读写流程"><a href="#2-2-librbd读写流程" class="headerlink" title="2.2 librbd读写流程"></a>2.2 librbd读写流程</h3><ol>
<li><em>image.read(data,0)<em>，通过image开始了一个写请求的生命的开始。这里指明了request的两个基本要素 buffer=data 和 offset=0。</em>image.read(data,0)<em>将会转化为librbd.cc文件中的</em>Image::read()</em> 函数，该函数中调用了ImageRequestWQ中的read的函数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Image::read</span><span class="params">(<span class="keyword">uint64_t</span> ofs, <span class="keyword">size_t</span> len, bufferlist&amp; bl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ImageCtx *ictx = (ImageCtx *)ctx;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">int</span> r = ictx-&gt;io_work_queue-&gt;<span class="built_in">read</span>(ofs, len, io::ReadResult&#123;&amp;bl&#125;, <span class="number">0</span>);</span><br><span class="line">  tracepoint(librbd, read_exit, r);</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>ImageRequestWQ::read中的实现。该函数的具体实现在ImageRequestWQ.cc文件中。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> ImageRequestWQ&lt;I&gt;::<span class="built_in">read</span>(<span class="keyword">uint64_t</span> off, <span class="keyword">uint64_t</span> len,</span><br><span class="line">                ReadResult &amp;&amp;read_result, <span class="keyword">int</span> op_flags) &#123;</span><br><span class="line">  CephContext *cct = m_image_ctx.cct;</span><br><span class="line">  ldout(cct, <span class="number">20</span>) &lt;&lt; <span class="string">&quot;ictx=&quot;</span> &lt;&lt; &amp;m_image_ctx &lt;&lt; <span class="string">&quot;, off=&quot;</span> &lt;&lt; off &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">                 &lt;&lt; <span class="string">&quot;len = &quot;</span> &lt;&lt; len &lt;&lt; dendl;</span><br><span class="line"></span><br><span class="line">  C_SaferCond cond;  <span class="comment">//---a</span></span><br><span class="line">  AioCompletion *c = AioCompletion::create(&amp;cond); <span class="comment">//---b</span></span><br><span class="line">  aio_read(c, off, len, <span class="built_in">std</span>::<span class="built_in">move</span>(read_result), op_flags, <span class="literal">false</span>); <span class="comment">//---c</span></span><br><span class="line">  <span class="keyword">return</span> cond.wait(); <span class="comment">//---d</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>a. 创建了一个等待机制的上下文。</li>
<li>b. 根据上下文创建回调函数，即aio_read完成后会调用的函数。</li>
<li>c. 该函数aio_read会继续处理这个读请求。</li>
<li>d. 知道cond.wait()结束，即aio_read调用回调函数时，程序结束。</li>
</ul>
<p>由上述步骤可知，ceph的同步读写实际上是在异步读写的基础上，加上同步机制实现的。</p>
<ol start="3">
<li>再来看看aio_write 拿到了 请求的offset和buffer会做点什么呢？</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="keyword">void</span> ImageRequestWQ&lt;I&gt;::aio_read(AioCompletion *c, <span class="keyword">uint64_t</span> off, <span class="keyword">uint64_t</span> len,</span><br><span class="line">                 ReadResult &amp;&amp;read_result, <span class="keyword">int</span> op_flags,</span><br><span class="line">                 <span class="keyword">bool</span> native_async) &#123;</span><br><span class="line">  CephContext *cct = m_image_ctx.cct;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function">RWLock::RLocker <span class="title">owner_locker</span><span class="params">(m_image_ctx.owner_lock)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (m_image_ctx.non_blocking_aio || writes_blocked() || !writes_empty() ||</span><br><span class="line">      require_lock_on_read()) &#123; <span class="comment">//---a</span></span><br><span class="line">    <span class="built_in">queue</span>(ImageDispatchSpec&lt;I&gt;::create_read_request(</span><br><span class="line">            m_image_ctx, c, &#123;&#123;off, len&#125;&#125;, <span class="built_in">std</span>::<span class="built_in">move</span>(read_result), op_flags,</span><br><span class="line">            trace));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;    <span class="comment">//---b</span></span><br><span class="line">    c-&gt;start_op();</span><br><span class="line">    ImageRequest&lt;I&gt;::aio_read(&amp;m_image_ctx, c, &#123;&#123;off, len&#125;&#125;,</span><br><span class="line">                  <span class="built_in">std</span>::<span class="built_in">move</span>(read_result), op_flags, trace);</span><br><span class="line">    finish_in_flight_io();</span><br><span class="line">  &#125;</span><br><span class="line">  trace.event(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里对输入的情况进行讨论。</p>
<ul>
<li>a. 如果输入后，发现写入队列不为空/日志被其他程序打开/写入区域已被阻塞/需要锁定当前数据，就会将当前写请求加入读写队列中。</li>
<li>b. 否则直接调用ImageRequet::aio_read操作进行读取。</li>
</ul>
<p>这里直接查看第二处的执行流程。实际上，在<em>ImageRequest::aio_read</em>函数中，读取请求按照下图的次序进入ImageReadRequest::send_reques*中，在该函数将对于块设备的读写请求转化为对于对象的读写请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    D[ImageRequestWQ::aio_read] --&gt; A</span><br><span class="line">    A[ImageRequest::aio_read] --&gt;B[ImageRequest::send]</span><br><span class="line">    B --&gt; C[ImageWriteRequest::send_request]</span><br></pre></td></tr></table></figure>



<ol start="4">
<li><em>ImageReadRequest::send_request</em>这个函数主要完成了块设备分割的功能。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageReadRequest&lt;I&gt;::send_request() &#123;</span><br><span class="line">  I &amp;image_ctx = <span class="keyword">this</span>-&gt;m_image_ctx;</span><br><span class="line">  CephContext *cct = image_ctx.cct;</span><br><span class="line">  ...</span><br><span class="line">      Striper::file_to_extents(cct, image_ctx.format_string, &amp;image_ctx.layout,</span><br><span class="line">                               extent.first, extent.second, <span class="number">0</span>, object_extents,</span><br><span class="line">                               buffer_ofs); <span class="comment">// ---a</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;object_extent : object_extents) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;extent : object_extent.second) &#123;</span><br><span class="line">      <span class="keyword">auto</span> req_comp = <span class="keyword">new</span> io::ReadResult::C_ObjectReadRequest(</span><br><span class="line">        aio_comp, extent.offset, extent.length,</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">move</span>(extent.buffer_extents));</span><br><span class="line">      <span class="keyword">auto</span> req = ObjectDispatchSpec::create_read(</span><br><span class="line">        &amp;image_ctx, OBJECT_DISPATCH_LAYER_NONE, extent.oid.name,</span><br><span class="line">        extent.objectno, extent.offset, extent.length, snap_id, m_op_flags,</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_trace, &amp;req_comp-&gt;bl, &amp;req_comp-&gt;extent_map, req_comp);</span><br><span class="line">      req-&gt;send();  <span class="comment">// ---b</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  aio_comp-&gt;<span class="built_in">put</span>();</span><br><span class="line"></span><br><span class="line">  image_ctx.perfcounter-&gt;inc(l_librbd_rd);</span><br><span class="line">  image_ctx.perfcounter-&gt;inc(l_librbd_rd_bytes, buffer_ofs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>a. 根据请求的大小需要将这个请求按着object进行划分，由函数<em>file_to_extents</em>进行处理，处理完成后按着object进行保存在extents中。该函数完成了原始请求的拆分。</li>
</ul>
<blockquote>
<p>一个rbd设备是有很多的object组成，也就是需要将rbd设备进行切块，每一个块叫做object，每个object的大小默认为4M，也可以自己指定。file_to_extents函数将这个大的请求分别映射到object上去，拆成了很多小的请求如下图。最后映射的结果保存在ObjectExtent中。</p>
<p><img src= "/img/loading.gif" data-src="http://static.oschina.net/uploads/space/2015/1119/145240_0zUe_2460844.jpg" alt="img"></p>
<p>原本的offset是指在rbd内的偏移量(写入rbd的位置)，经过file_to_extents后，转化成了一个或者多个object的内部的偏移量offset0。这样转化后处理一批这个object内的请求。</p>
</blockquote>
<ul>
<li>b. 调用<em>ObjectDispatchSpec::send</em>，将分割后的对象读请求进行分发、处理。</li>
</ul>
<ol start="5">
<li><em>ObjectDispatchSpac::send</em>函数将会按照下图次序进入函数*ImageReadRequest::send_request()*：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    D[ObjectDispatchSpac::send] --&gt; A[ObjectDispatcherInterface::send]</span><br><span class="line">    A --&gt;B[ObjectDispatcher::send]</span><br><span class="line">    B --&gt; C[ImageReadRequest::send_request]</span><br></pre></td></tr></table></figure>



<p>函数<em>ImageReadRequest::send_request</em>将创建一个SendVistor，由观察者继续读写流程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectDispatcher&lt;I&gt;::send(ObjectDispatchSpec* object_dispatch_spec) &#123;</span><br><span class="line">  <span class="keyword">auto</span> cct = m_image_ctx-&gt;cct;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">bool</span> handled = boost::apply_visitor(</span><br><span class="line">      SendVisitor&#123;object_dispatch, object_dispatch_spec&#125;,</span><br><span class="line">      object_dispatch_spec-&gt;request);</span><br><span class="line">    object_dispatch_meta.async_op_tracker-&gt;finish_op(); <span class="comment">// 创建SendVistor</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// handled ops will resume when the dispatch ctx is invoked</span></span><br><span class="line">    <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  object_dispatch_spec-&gt;dispatcher_ctx.complete(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="6">
<li>进入<em>ObjectDispatcher::SendVisitor</em>函数，发现读流程如下图，最终调用了<em>read_object</em>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    D[ObjectDispatcher::SendVisitor] --&gt; A[ObjectDispatchInterface::read]</span><br><span class="line">    A --&gt;B[ObjectDispatch::read]</span><br><span class="line">    B --&gt; C[ObjectReadRequest::read]</span><br><span class="line">    C --&gt; E[ObjectReadRequest::read_object]</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>最终在函数<em>read_object</em>中调用了rados对于对象的读写接口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectReadRequest&lt;I&gt;::read_object() &#123;</span><br><span class="line">  I *image_ctx = <span class="keyword">this</span>-&gt;m_ictx;</span><br><span class="line">  ...</span><br><span class="line">  librados::ObjectReadOperation op; <span class="comment">// ---a</span></span><br><span class="line">  ...</span><br><span class="line">  librados::AioCompletion *rados_completion = util::create_rados_callback&lt;</span><br><span class="line">    ObjectReadRequest&lt;I&gt;, &amp;ObjectReadRequest&lt;I&gt;::handle_read_object&gt;(<span class="keyword">this</span>); <span class="comment">// ---b</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> flags = image_ctx-&gt;get_read_flags(<span class="keyword">this</span>-&gt;m_snap_id);</span><br><span class="line">  <span class="keyword">int</span> r = image_ctx-&gt;data_ctx.aio_operate(</span><br><span class="line">    data_object_name(<span class="keyword">this</span>-&gt;m_ictx, <span class="keyword">this</span>-&gt;m_object_no), rados_completion, &amp;op,</span><br><span class="line">    flags, <span class="literal">nullptr</span>,</span><br><span class="line">    (<span class="keyword">this</span>-&gt;m_trace.valid() ? <span class="keyword">this</span>-&gt;m_trace.get_info() : <span class="literal">nullptr</span>)); <span class="comment">// ---c</span></span><br><span class="line">  ceph_assert(r == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  rados_completion-&gt;<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>a. 创建对象操作。这里将根据具体情况选择进行<em>read</em>或<em>sparse_read</em>操作。</li>
<li>b. 创建回调函数。这里创建了读取操作的回调函数，回调函数将会返回读取道德结果</li>
<li>c.  <code>int r = image_ctx-&gt;data_ctx.aio_operate</code>语句中，data_ctx即为当前image所在存储池的IoCtx对象。通过调用IoCtx对象的接口，最终将读写请求交付到了librados的相关接口。</li>
</ul>
<h3 id="2-3-librbd小结"><a href="#2-3-librbd小结" class="headerlink" title="2.3 librbd小结"></a>2.3 librbd小结</h3><p>上文已经介绍，librbd的基本功能是将块存储的请求转化为对象存储。事实上，librbd实现的功能远远不止这些。包括调用rados的snap机制完成<strong>快照</strong>，借助journal完成<strong>镜像</strong>功能，并能在故障后进行<strong>故障恢复</strong>，完成<strong>回滚</strong>操作等等。</p>
<p>为了保证块设备的正常运行，librbd中还需要管理大量的其他数据，这些数据都会以对象的形式存储在rados分布式存储系统中。包括：</p>
<ul>
<li>元数据：rbd _dircetory，rbd_id，rbd_head，rbd_object_map等</li>
<li>cache数据：cache_object，cache_parent，cache_writeAround等</li>
<li>日志数据：journal</li>
</ul>
<p>因为需要实现的功能太过繁杂，librbd的代码十分复杂。对librbd进行全文件夹搜索，发现其对librados的接口调用多达<strong>1042</strong>处。</p>
<p>[^1]: <a target="_blank" rel="noopener" href="https://blog.csdn.net/hit1944/article/details/38330975">ceph的librados api解释</a><br>[^2]: <a target="_blank" rel="noopener" href="https://my.oschina.net/u/2271251/blog/369820">ceph librados接口说明</a><br>[^3]: <a target="_blank" rel="noopener" href="https://blog.csdn.net/csnd_pan/article/details/78728743">Ceph学习——Librbd块存储库与RBD读写流程源码分析</a><br>[^4]: <a target="_blank" rel="noopener" href="https://zhoubofsy.github.io/2017/01/22/storage/ceph/librbd-frame-analyse/">librbd 架构分析</a><br>[^5]: <a target="_blank" rel="noopener" href="https://my.oschina.net/u/2460844/blog/532755">ceph的数据存储之路(4) —– rbd client 端的数据请求处理</a><br>[^6]: <a target="_blank" rel="noopener" href="https://docs.ceph.com/docs/master/rados/operations/cache-tiering/">Ceph Tiering官方文档</a> </p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Chaos Dong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/07/29/Ceph%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-1/">http://yoursite.com/2020/07/29/Ceph%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">Chaos' Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Ceph/">Ceph</a><a class="post-meta__tags" href="/tags/RBD/">RBD</a><a class="post-meta__tags" href="/tags/RADOS/">RADOS</a><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post_share"><div class="social-share" data-image="http://static.oschina.net/uploads/space/2015/1119/145240_0zUe_2460844.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/07/29/hello-world/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(http://static.oschina.net/uploads/space/2015/1119/145240_0zUe_2460844.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Chaos Dong</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">简</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script></body></html>